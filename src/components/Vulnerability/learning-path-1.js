import React from "react";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { dark } from "react-syntax-highlighter/dist/esm/styles/prism";
import "./challenge1.css";

const LearningPath1 = () => {

  return (
    <div className="challenge1-container">
      <h1>Learning Path 1: Buffer Overflow</h1>
      <p>
      1. Understand Buffer Overflow
 What is Buffer Overflow? It's a vulnerability where more data is written to a
buffer than it can handle, overwriting adjacent memory and potentially causing
crashes or security breaches.
 Learn more: OWASP Buffer Overflow Guide

2. Use Safe Coding Practices
A. Replace Unsafe Functions
Avoid functions like strcpy, strcat, gets, and scanf which don't perform bounds checking.
Instead, use safer alternatives:
 Use strncpy, strncat, and fgets:
o Example:

c
Copy code

<SyntaxHighlighter language="c" style={dark}>
char dest[10];
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0'; // Ensure null-termination
</SyntaxHighlighter>
o Resource: Safer String Handling in C

B. Validate Input Size
 Always validate the length of user input before copying it into a buffer:
c
Copy code
<SyntaxHighlighter language="c" style={dark}>
{"if (strlen(input) &lt; BUFFER_SIZE) { strcpy(buffer, input);} else {fprintf(stderr, \"Input too large\");}"}</SyntaxHighlighter>

 Learn more: Input Validation Best Practices

C. Use Format Specifiers in Functions
 For functions like printf and scanf, use format specifiers to prevent buffer
overflows:
c
Copy code
<SyntaxHighlighter language="c" style={dark}>
char input[50];
scanf(&quot;%49s&quot;, input); // Limit input to prevent overflow
</SyntaxHighlighter>
3. Enable Compiler Protections
 Modern compilers have built-in tools to mitigate buffer overflows:
o Stack Canaries: Detect stack corruption by placing a random value
(canary) before the return address.
 Use -fstack-protector or -fstack-protector-strong with GCC/Clang.
o Address Space Layout Randomization (ASLR): Randomizes memory
layout to make exploits harder.
 Ensure your OS and binaries support ASLR.
o Learn more: GCC Compiler Options

4. Use Bounds-Checked Libraries
 Replace standard C libraries with safer alternatives:
o Safe C Library: safeclib offers functions like strcpy_s.
o Example:

c
Copy code

<SyntaxHighlighter language="c" style={dark}>
strcpy_s(dest, sizeof(dest), src);
</SyntaxHighlighter>
o Learn more: Safe String Library Overview

5. Static Analysis and Fuzz Testing
 Use static analysis tools to detect potential vulnerabilities in your code:
o Tools: Coverity, Cppcheck, CodeQL
 Fuzz your program to identify buffer overflow conditions:
o Tools: AFL, LibFuzzer

6. Adopt Memory-Safe Languages
 Whenever possible, use languages with built-in memory safety, such as Rust,
Go, or Python.
 Learn more: Why Use Memory-Safe Languages

7. Resources for Further Learning
 Book: The Art of Software Security Assessment (Mark Dowd et al.) – Covers
buffer overflow and other vulnerabilities in-depth.
 Tutorial: Buffer Overflow Exploitation Tutorial – Learn how to exploit and prevent
it.
 Course: Coursera Secure Coding Practices – Training for secure programming.
      </p>
    </div>
  );
};

export default LearningPath1;
